#include "main.h"
  #define BUFF 128
int __exec(char **);
/**
 * execmd - attempts a system call
 *
 * args: name of program to execute
 *
 * Return: 0
 */
int execmd(char **argv)
{
	pid_t pid;
	/**This var will check if child is finished to call exit*/
	int status;

	/**>Fork the function first and save the PID so the parent can wait*/
	pid = fork();

	/** Remember fork returns twice, 1 for parent, 0 for child*/
	if (pid == 0)
	{
	  if (__exec(argv) == -1)
	    perror("42 Error: ");
	  exit(EXIT_FAILURE);
	}
	else if (pid < 0) /** If <0, something went wrong forking*/
		perror("43 Error: ");
	else /** if it isnt 0 or -1 then the parent waits for child to die*/
	{ /** use a do here so it runs once before checking */
		do {
			pid = waitpid(pid, &status, WUNTRACED);
		} while (!WIFEXITED(status) && !WIFSIGNALED(status));
			/** Use the wifexited and wifsignaled to check if child
			was exited or cancelled. so parent can stop waiting*/
	}
	return (0);
}

int __exec(char **argv)
{
  char *rawPathz, *pathz[BUFF], *newpath[BUFF];
  int i = 0;

  rawPathz = getenv("PATH");
  pathz[0] = strtok(rawPathz, ":");

  while (1)
    {
      while (i < BUFF)
	newpath[i++] = NULL;

      *pathz = strtok(NULL, ":");
      if (!*pathz)
	{
	  perror("42 Error");
	  return(-1);
	}

      strcat(*newpath, *pathz);
      strcat(*newpath, "/");
      strcat(*newpath, argv[0]);
      execve((const char*)newpath, argv, NULL);
      
      i = 0;
    }
  return (0);
}
